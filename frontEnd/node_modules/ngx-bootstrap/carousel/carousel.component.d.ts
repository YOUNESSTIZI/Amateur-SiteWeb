/***
 * pause (not yet supported) (?string='hover') - event group name which pauses
 * the cycling of the carousel, if hover pauses on mouseenter and resumes on
 * mouseleave keyboard (not yet supported) (?boolean=true) - if false
 * carousel will not react to keyboard events
 * note: swiping not yet supported
 */
/****
 * Problems:
 * 1) if we set an active slide via model changes, .active class remains on a
 * current slide.
 * 2) if we have only one slide, we shouldn't show prev/next nav buttons
 * 3) if first or last slide is active and noWrap is true, there should be
 * "disabled" class on the nav buttons.
 * 4) default interval should be equal 5000
 */
import { EventEmitter, NgZone, OnDestroy, AfterViewInit } from '@angular/core';
import { LinkedList } from 'ngx-bootstrap/utils';
import { SlideComponent } from './slide.component';
import { CarouselConfig } from './carousel.config';
import { SlideWithIndex } from './models';
import * as ɵngcc0 from '@angular/core';
export declare enum Direction {
    UNKNOWN = 0,
    NEXT = 1,
    PREV = 2
}
/**
 * Base element to create carousel
 */
export declare class CarouselComponent implements AfterViewInit, OnDestroy {
    private ngZone;
    noWrap: boolean;
    noPause: boolean;
    showIndicators: boolean;
    pauseOnFocus: boolean;
    indicatorsByChunk: boolean;
    itemsPerSlide: number;
    singleSlideOffset: boolean;
    /** Turn on/off animation. Animation doesn't work for multilist carousel */
    isAnimated: boolean;
    /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */
    activeSlideChange: EventEmitter<number>;
    /** Will be emitted when active slides has been changed in multilist mode */
    slideRangeChange: EventEmitter<number[]>;
    /** Index of currently displayed slide(started for 0) */
    activeSlide: number;
    startFromIndex: number;
    /**
     * Delay of item cycling in milliseconds. If false, carousel won't cycle
     * automatically.
     */
    interval: number;
    readonly slides: SlideComponent[];
    protected currentInterval: any;
    protected _currentActiveSlide: number;
    protected _interval: number;
    protected _slides: LinkedList<SlideComponent>;
    protected _chunkedSlides: SlideWithIndex[][];
    protected _slidesWithIndexes: SlideWithIndex[];
    protected _currentVisibleSlidesIndex: number;
    protected isPlaying: boolean;
    protected destroyed: boolean;
    readonly isBs4: boolean;
    constructor(config: CarouselConfig, ngZone: NgZone);
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    /**
     * Adds new slide. If this slide is first in collection - set it as active
     * and starts auto changing
     * @param slide
     */
    addSlide(slide: SlideComponent): void;
    /**
     * Removes specified slide. If this slide is active - will roll to another
     * slide
     * @param slide
     */
    removeSlide(slide: SlideComponent): void;
    nextSlideFromInterval(force?: boolean): void;
    /**
     * Rolling to next slide
     * @param force: {boolean} if true - will ignore noWrap flag
     */
    nextSlide(force?: boolean): void;
    /**
     * Rolling to previous slide
     * @param force: {boolean} if true - will ignore noWrap flag
     */
    previousSlide(force?: boolean): void;
    getFirstVisibleIndex(): number;
    getLastVisibleIndex(): number;
    getActive: (slide: SlideComponent) => boolean;
    move(direction: Direction, force?: boolean): void;
    /**
     * Swith slides by enter, space and arrows keys
     * @internal
     */
    keydownPress(event: KeyboardEvent): void;
    /**
     * Play on mouse leave
     * @internal
     */
    onMouseLeave(): void;
    /**
     * Play on mouse up
     * @internal
     */
    onMouseUp(): void;
    /**
     * When slides on focus autoplay is stopped(optional)
     * @internal
     */
    pauseFocusIn(): void;
    /**
     * When slides out of focus autoplay is started
     * @internal
     */
    pauseFocusOut(): void;
    /**
     * Rolling to specified slide
     * @param index: {number} index of slide, which must be shown
     */
    selectSlide(index: number): void;
    /**
     * Starts a auto changing of slides
     */
    play(): void;
    /**
     * Stops a auto changing of slides
     */
    pause(): void;
    /**
     * Finds and returns index of currently displayed slide
     */
    getCurrentSlideIndex(): number;
    /**
     * Defines, whether the specified index is last in collection
     * @param index
     */
    isLast(index: number): boolean;
    /**
     * Defines, whether the specified index is first in collection
     * @param index
     */
    isFirst(index: number): boolean;
    indicatorsSlides(): SlideComponent[];
    private selectInitialSlides;
    /**
     * Defines next slide index, depending of direction
     * @param direction: Direction(UNKNOWN|PREV|NEXT)
     * @param force: {boolean} if TRUE - will ignore noWrap flag, else will
     *   return undefined if next slide require wrapping
     */
    private findNextSlideIndex;
    private mapSlidesAndIndexes;
    private selectSlideRange;
    private selectRangeByNestedIndex;
    private isIndexOnTheEdges;
    private isIndexInRange;
    private hideSlides;
    private isVisibleSlideListLast;
    private isVisibleSlideListFirst;
    private moveSliderByOneItem;
    private makeSlidesConsistent;
    private moveMultilist;
    private getVisibleIndexes;
    /**
     * Sets a slide, which specified through index, as active
     * @param index
     */
    private _select;
    /**
     * Starts loop of auto changing of slides
     */
    private restartTimer;
    readonly multilist: boolean;
    /**
     * Stops loop of auto changing of slides
     */
    private resetTimer;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CarouselComponent>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<CarouselComponent, "carousel", never, {
    "indicatorsByChunk": "indicatorsByChunk";
    "itemsPerSlide": "itemsPerSlide";
    "singleSlideOffset": "singleSlideOffset";
    "isAnimated": "isAnimated";
    "startFromIndex": "startFromIndex";
    "activeSlide": "activeSlide";
    "interval": "interval";
    "noWrap": "noWrap";
    "noPause": "noPause";
    "showIndicators": "showIndicators";
    "pauseOnFocus": "pauseOnFocus";
}, {
    "activeSlideChange": "activeSlideChange";
    "slideRangeChange": "slideRangeChange";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Fyb3VzZWwuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbImNhcm91c2VsLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStKQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKipcbiAqIHBhdXNlIChub3QgeWV0IHN1cHBvcnRlZCkgKD9zdHJpbmc9J2hvdmVyJykgLSBldmVudCBncm91cCBuYW1lIHdoaWNoIHBhdXNlc1xuICogdGhlIGN5Y2xpbmcgb2YgdGhlIGNhcm91c2VsLCBpZiBob3ZlciBwYXVzZXMgb24gbW91c2VlbnRlciBhbmQgcmVzdW1lcyBvblxuICogbW91c2VsZWF2ZSBrZXlib2FyZCAobm90IHlldCBzdXBwb3J0ZWQpICg/Ym9vbGVhbj10cnVlKSAtIGlmIGZhbHNlXG4gKiBjYXJvdXNlbCB3aWxsIG5vdCByZWFjdCB0byBrZXlib2FyZCBldmVudHNcbiAqIG5vdGU6IHN3aXBpbmcgbm90IHlldCBzdXBwb3J0ZWRcbiAqL1xuLyoqKipcbiAqIFByb2JsZW1zOlxuICogMSkgaWYgd2Ugc2V0IGFuIGFjdGl2ZSBzbGlkZSB2aWEgbW9kZWwgY2hhbmdlcywgLmFjdGl2ZSBjbGFzcyByZW1haW5zIG9uIGFcbiAqIGN1cnJlbnQgc2xpZGUuXG4gKiAyKSBpZiB3ZSBoYXZlIG9ubHkgb25lIHNsaWRlLCB3ZSBzaG91bGRuJ3Qgc2hvdyBwcmV2L25leHQgbmF2IGJ1dHRvbnNcbiAqIDMpIGlmIGZpcnN0IG9yIGxhc3Qgc2xpZGUgaXMgYWN0aXZlIGFuZCBub1dyYXAgaXMgdHJ1ZSwgdGhlcmUgc2hvdWxkIGJlXG4gKiBcImRpc2FibGVkXCIgY2xhc3Mgb24gdGhlIG5hdiBidXR0b25zLlxuICogNCkgZGVmYXVsdCBpbnRlcnZhbCBzaG91bGQgYmUgZXF1YWwgNTAwMFxuICovXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIE5nWm9uZSwgT25EZXN0cm95LCBBZnRlclZpZXdJbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBMaW5rZWRMaXN0IH0gZnJvbSAnbmd4LWJvb3RzdHJhcC91dGlscyc7XG5pbXBvcnQgeyBTbGlkZUNvbXBvbmVudCB9IGZyb20gJy4vc2xpZGUuY29tcG9uZW50JztcbmltcG9ydCB7IENhcm91c2VsQ29uZmlnIH0gZnJvbSAnLi9jYXJvdXNlbC5jb25maWcnO1xuaW1wb3J0IHsgU2xpZGVXaXRoSW5kZXggfSBmcm9tICcuL21vZGVscyc7XG5leHBvcnQgZGVjbGFyZSBlbnVtIERpcmVjdGlvbiB7XG4gICAgVU5LTk9XTiA9IDAsXG4gICAgTkVYVCA9IDEsXG4gICAgUFJFViA9IDJcbn1cbi8qKlxuICogQmFzZSBlbGVtZW50IHRvIGNyZWF0ZSBjYXJvdXNlbFxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBDYXJvdXNlbENvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBuZ1pvbmU7XG4gICAgbm9XcmFwOiBib29sZWFuO1xuICAgIG5vUGF1c2U6IGJvb2xlYW47XG4gICAgc2hvd0luZGljYXRvcnM6IGJvb2xlYW47XG4gICAgcGF1c2VPbkZvY3VzOiBib29sZWFuO1xuICAgIGluZGljYXRvcnNCeUNodW5rOiBib29sZWFuO1xuICAgIGl0ZW1zUGVyU2xpZGU6IG51bWJlcjtcbiAgICBzaW5nbGVTbGlkZU9mZnNldDogYm9vbGVhbjtcbiAgICAvKiogVHVybiBvbi9vZmYgYW5pbWF0aW9uLiBBbmltYXRpb24gZG9lc24ndCB3b3JrIGZvciBtdWx0aWxpc3QgY2Fyb3VzZWwgKi9cbiAgICBpc0FuaW1hdGVkOiBib29sZWFuO1xuICAgIC8qKiBXaWxsIGJlIGVtaXR0ZWQgd2hlbiBhY3RpdmUgc2xpZGUgaGFzIGJlZW4gY2hhbmdlZC4gUGFydCBvZiB0d28td2F5LWJpbmRhYmxlIFsoYWN0aXZlU2xpZGUpXSBwcm9wZXJ0eSAqL1xuICAgIGFjdGl2ZVNsaWRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8bnVtYmVyPjtcbiAgICAvKiogV2lsbCBiZSBlbWl0dGVkIHdoZW4gYWN0aXZlIHNsaWRlcyBoYXMgYmVlbiBjaGFuZ2VkIGluIG11bHRpbGlzdCBtb2RlICovXG4gICAgc2xpZGVSYW5nZUNoYW5nZTogRXZlbnRFbWl0dGVyPG51bWJlcltdPjtcbiAgICAvKiogSW5kZXggb2YgY3VycmVudGx5IGRpc3BsYXllZCBzbGlkZShzdGFydGVkIGZvciAwKSAqL1xuICAgIGFjdGl2ZVNsaWRlOiBudW1iZXI7XG4gICAgc3RhcnRGcm9tSW5kZXg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBEZWxheSBvZiBpdGVtIGN5Y2xpbmcgaW4gbWlsbGlzZWNvbmRzLiBJZiBmYWxzZSwgY2Fyb3VzZWwgd29uJ3QgY3ljbGVcbiAgICAgKiBhdXRvbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIGludGVydmFsOiBudW1iZXI7XG4gICAgcmVhZG9ubHkgc2xpZGVzOiBTbGlkZUNvbXBvbmVudFtdO1xuICAgIHByb3RlY3RlZCBjdXJyZW50SW50ZXJ2YWw6IGFueTtcbiAgICBwcm90ZWN0ZWQgX2N1cnJlbnRBY3RpdmVTbGlkZTogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBfaW50ZXJ2YWw6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgX3NsaWRlczogTGlua2VkTGlzdDxTbGlkZUNvbXBvbmVudD47XG4gICAgcHJvdGVjdGVkIF9jaHVua2VkU2xpZGVzOiBTbGlkZVdpdGhJbmRleFtdW107XG4gICAgcHJvdGVjdGVkIF9zbGlkZXNXaXRoSW5kZXhlczogU2xpZGVXaXRoSW5kZXhbXTtcbiAgICBwcm90ZWN0ZWQgX2N1cnJlbnRWaXNpYmxlU2xpZGVzSW5kZXg6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgaXNQbGF5aW5nOiBib29sZWFuO1xuICAgIHByb3RlY3RlZCBkZXN0cm95ZWQ6IGJvb2xlYW47XG4gICAgcmVhZG9ubHkgaXNCczQ6IGJvb2xlYW47XG4gICAgY29uc3RydWN0b3IoY29uZmlnOiBDYXJvdXNlbENvbmZpZywgbmdab25lOiBOZ1pvbmUpO1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQWRkcyBuZXcgc2xpZGUuIElmIHRoaXMgc2xpZGUgaXMgZmlyc3QgaW4gY29sbGVjdGlvbiAtIHNldCBpdCBhcyBhY3RpdmVcbiAgICAgKiBhbmQgc3RhcnRzIGF1dG8gY2hhbmdpbmdcbiAgICAgKiBAcGFyYW0gc2xpZGVcbiAgICAgKi9cbiAgICBhZGRTbGlkZShzbGlkZTogU2xpZGVDb21wb25lbnQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgc3BlY2lmaWVkIHNsaWRlLiBJZiB0aGlzIHNsaWRlIGlzIGFjdGl2ZSAtIHdpbGwgcm9sbCB0byBhbm90aGVyXG4gICAgICogc2xpZGVcbiAgICAgKiBAcGFyYW0gc2xpZGVcbiAgICAgKi9cbiAgICByZW1vdmVTbGlkZShzbGlkZTogU2xpZGVDb21wb25lbnQpOiB2b2lkO1xuICAgIG5leHRTbGlkZUZyb21JbnRlcnZhbChmb3JjZT86IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJvbGxpbmcgdG8gbmV4dCBzbGlkZVxuICAgICAqIEBwYXJhbSBmb3JjZToge2Jvb2xlYW59IGlmIHRydWUgLSB3aWxsIGlnbm9yZSBub1dyYXAgZmxhZ1xuICAgICAqL1xuICAgIG5leHRTbGlkZShmb3JjZT86IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJvbGxpbmcgdG8gcHJldmlvdXMgc2xpZGVcbiAgICAgKiBAcGFyYW0gZm9yY2U6IHtib29sZWFufSBpZiB0cnVlIC0gd2lsbCBpZ25vcmUgbm9XcmFwIGZsYWdcbiAgICAgKi9cbiAgICBwcmV2aW91c1NsaWRlKGZvcmNlPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgZ2V0Rmlyc3RWaXNpYmxlSW5kZXgoKTogbnVtYmVyO1xuICAgIGdldExhc3RWaXNpYmxlSW5kZXgoKTogbnVtYmVyO1xuICAgIGdldEFjdGl2ZTogKHNsaWRlOiBTbGlkZUNvbXBvbmVudCkgPT4gYm9vbGVhbjtcbiAgICBtb3ZlKGRpcmVjdGlvbjogRGlyZWN0aW9uLCBmb3JjZT86IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFN3aXRoIHNsaWRlcyBieSBlbnRlciwgc3BhY2UgYW5kIGFycm93cyBrZXlzXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAga2V5ZG93blByZXNzKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBQbGF5IG9uIG1vdXNlIGxlYXZlXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgb25Nb3VzZUxlYXZlKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUGxheSBvbiBtb3VzZSB1cFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG9uTW91c2VVcCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFdoZW4gc2xpZGVzIG9uIGZvY3VzIGF1dG9wbGF5IGlzIHN0b3BwZWQob3B0aW9uYWwpXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcGF1c2VGb2N1c0luKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogV2hlbiBzbGlkZXMgb3V0IG9mIGZvY3VzIGF1dG9wbGF5IGlzIHN0YXJ0ZWRcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwYXVzZUZvY3VzT3V0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUm9sbGluZyB0byBzcGVjaWZpZWQgc2xpZGVcbiAgICAgKiBAcGFyYW0gaW5kZXg6IHtudW1iZXJ9IGluZGV4IG9mIHNsaWRlLCB3aGljaCBtdXN0IGJlIHNob3duXG4gICAgICovXG4gICAgc2VsZWN0U2xpZGUoaW5kZXg6IG51bWJlcik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgYXV0byBjaGFuZ2luZyBvZiBzbGlkZXNcbiAgICAgKi9cbiAgICBwbGF5KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogU3RvcHMgYSBhdXRvIGNoYW5naW5nIG9mIHNsaWRlc1xuICAgICAqL1xuICAgIHBhdXNlKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogRmluZHMgYW5kIHJldHVybnMgaW5kZXggb2YgY3VycmVudGx5IGRpc3BsYXllZCBzbGlkZVxuICAgICAqL1xuICAgIGdldEN1cnJlbnRTbGlkZUluZGV4KCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzLCB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgaW5kZXggaXMgbGFzdCBpbiBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICovXG4gICAgaXNMYXN0KGluZGV4OiBudW1iZXIpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIERlZmluZXMsIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBpbmRleCBpcyBmaXJzdCBpbiBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICovXG4gICAgaXNGaXJzdChpbmRleDogbnVtYmVyKTogYm9vbGVhbjtcbiAgICBpbmRpY2F0b3JzU2xpZGVzKCk6IFNsaWRlQ29tcG9uZW50W107XG4gICAgcHJpdmF0ZSBzZWxlY3RJbml0aWFsU2xpZGVzO1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgbmV4dCBzbGlkZSBpbmRleCwgZGVwZW5kaW5nIG9mIGRpcmVjdGlvblxuICAgICAqIEBwYXJhbSBkaXJlY3Rpb246IERpcmVjdGlvbihVTktOT1dOfFBSRVZ8TkVYVClcbiAgICAgKiBAcGFyYW0gZm9yY2U6IHtib29sZWFufSBpZiBUUlVFIC0gd2lsbCBpZ25vcmUgbm9XcmFwIGZsYWcsIGVsc2Ugd2lsbFxuICAgICAqICAgcmV0dXJuIHVuZGVmaW5lZCBpZiBuZXh0IHNsaWRlIHJlcXVpcmUgd3JhcHBpbmdcbiAgICAgKi9cbiAgICBwcml2YXRlIGZpbmROZXh0U2xpZGVJbmRleDtcbiAgICBwcml2YXRlIG1hcFNsaWRlc0FuZEluZGV4ZXM7XG4gICAgcHJpdmF0ZSBzZWxlY3RTbGlkZVJhbmdlO1xuICAgIHByaXZhdGUgc2VsZWN0UmFuZ2VCeU5lc3RlZEluZGV4O1xuICAgIHByaXZhdGUgaXNJbmRleE9uVGhlRWRnZXM7XG4gICAgcHJpdmF0ZSBpc0luZGV4SW5SYW5nZTtcbiAgICBwcml2YXRlIGhpZGVTbGlkZXM7XG4gICAgcHJpdmF0ZSBpc1Zpc2libGVTbGlkZUxpc3RMYXN0O1xuICAgIHByaXZhdGUgaXNWaXNpYmxlU2xpZGVMaXN0Rmlyc3Q7XG4gICAgcHJpdmF0ZSBtb3ZlU2xpZGVyQnlPbmVJdGVtO1xuICAgIHByaXZhdGUgbWFrZVNsaWRlc0NvbnNpc3RlbnQ7XG4gICAgcHJpdmF0ZSBtb3ZlTXVsdGlsaXN0O1xuICAgIHByaXZhdGUgZ2V0VmlzaWJsZUluZGV4ZXM7XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHNsaWRlLCB3aGljaCBzcGVjaWZpZWQgdGhyb3VnaCBpbmRleCwgYXMgYWN0aXZlXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICovXG4gICAgcHJpdmF0ZSBfc2VsZWN0O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBsb29wIG9mIGF1dG8gY2hhbmdpbmcgb2Ygc2xpZGVzXG4gICAgICovXG4gICAgcHJpdmF0ZSByZXN0YXJ0VGltZXI7XG4gICAgcmVhZG9ubHkgbXVsdGlsaXN0OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFN0b3BzIGxvb3Agb2YgYXV0byBjaGFuZ2luZyBvZiBzbGlkZXNcbiAgICAgKi9cbiAgICBwcml2YXRlIHJlc2V0VGltZXI7XG59XG4iXX0=